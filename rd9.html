<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>9. Regression Discontinuity Designs</title>
    <meta charset="utf-8" />
    <meta name="date" content="2023-11-02" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: middle, center, title-slide

.title[
# 9. Regression Discontinuity Designs
]
.date[
### 2 November 2023
]

---






### Warm-Up


Suppose you want to assess the impact of social insurance (welfare) on employment rates. 

The theory is that welfare reduces the incentive to look for work.

Before 1989, welfare recipients in Quebec under age 30 received lower benefits (~185 per month) than recipients over age 30 (~507 per month). 

&lt;!-- The employment rate all people (aged 18-29) receiving low benefits is around 0.67, whereas it is around 0.57 for all people (aged 30-65) receiving high benefits.  --&gt;

Can we simply compare employment rates of older vs. younger people to estimate the causal effects of welfare generosity on employment?


---

### Some notation

- We have `\(n\)` units, indexed by `\(i\)` = 1, 2, ..., `\(n\)`

- Each unit has a score (or "running variable") `\(X_i\)`

- `\(x_0\)` is a known cutoff

- Units with `\(X_i &gt; x_0\)` are assigned to the treatment condition, and units with `\(X_i &lt; x_0\)` are assigned to control.

- The probability of receiving the treatment thus changes abruptly at the known threshold 

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/sharpfuzzy.png" width="550px" /&gt;
]

---

### RDD's Appeal

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rdd_popularity.png" width="550px" /&gt;
]

---


### Potential Outcomes

.pull-left[
- Potential outcomes:
$$
Y_i =
`\begin{cases}
    Y_i(1)  &amp; \text{if} \;  X_i &gt; x_0 \\
    Y_i(0)  &amp; \text{if} \;  X_i &lt; x_0
\end{cases}`
$$
- Potential outcomes are (often) substantively correlated with the rating variable `\(X\)`

- **Common support** exists only at the threshold itself! 

- You are estimating a Local Average Treatment Effect (LATE)
]

.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rddtx.png" width="475px" /&gt;
]



---

### Graphical Inspection of Real Data


.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/reardon_outcomescatter1.png" width="600px" /&gt;
]

---

### Graphical Inspection of Binned Data

In case the outcome data are noisy (or dichotomous), you can use bins:

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/reardon_outcomescatter2.png" width="900px" /&gt;
]

--

How should **pre-treatment covariates** behave at the threshold?

---

### A quick exercise

In some US states, anti-discrimination laws are enforced only for companies with 15 or more employees.

Consider a RDD design that studies the effects of these laws on minority hiring by comparing firms with 13 or 14 employees against firms with 15 or 16 employees.

Do you think that "treatment" (i.e. being subject to the law) is "as-if" randomly assigned within this set of firms?

How would you to check the plausibility of this assumption?

---

### Check for (self-)sorting around the cutoff

We should observe similar density on either side of the cutoff.

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/reardon_histograms.png" width="900px" /&gt;
]

---

### Check for (self-)sorting around the cutoff

- McCrary Test: estimate the "counts" and test if they are discontinuous at the cutoff

- Implement using rddensity()

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/mccrary.png" width="900px" /&gt;
]


---

### Two Estimation Approaches

&lt;br&gt;

1. RD as extrapolation

2. RD as a local experiment




---

### RDD as Extrapolation

.pull-left[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rddtx.png" width="475px" /&gt;
]

.pull-right[

&lt;br&gt;

- Assumes that `\(E[Y_1 | X]\)` and `\(E[Y_0 | X]\)` are continuous functions at the cutoff

- If we extrapolate these lines to the cutoff itself, we can estimate both `\(\alpha_1\)` and `\(\alpha_0\)`

- **In the voting example, what does this mean in substantive terms?**

- Remember: the effect is extremely local!

]


---

### Parametric Estimation 

.pull-left[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/elsner1.png" width="475px" /&gt;
]

.pull-right[

Linear model:
$$
y = \alpha + \beta_1 X + \beta_2 D + \beta_3 X \times D + \epsilon
$$
where: 

- `\(X\)` is rating variable, centered at cutoff `\(x_0\)`

- `\(D\)` is a dummy for `\(X &gt; x_0\)`

The interaction allows different slopes on different sides of the cutoff.

We can also estimate quadratic (and higher order) polynomials.

]

---

### The Importance of Functional Form

.pull-left[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/elsner2.png" width="475px" /&gt;

The "true" effect is 0, but RD gives the wrong answer!

]

--

.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/elsner3.png" width="475px" /&gt;

Linear vs. quadratic fits provide different answers!

]

--


We don't know the "true" functional form

Global polynomial fits are influenced by data far away from the cutoff

---

### Beware Overfitting!

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/huai1.jpg" width="900px" /&gt;
]

---

### Beware Overfitting!

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/huai2.jpg" width="900px" /&gt;
]

---
### Nonparametric Estimation

.pull-left[

&lt;br&gt;

- Selecting smaller bandwidths closer to the cutoff provides better (linear) fits of the underlying data


]


.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rddbw.png" width="500px" /&gt;
]

---
### Nonparametric Estimation

.pull-left[

&lt;br&gt;

- Selecting smaller bandwidths closer to the cutoff provides better (linear) fits of the underlying data

- You can also weight observations within the bandwidth.

]


.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rdkernels.png" width="600px" /&gt;
]


---
### Nonparametric Estimation

.pull-left[

&lt;br&gt;

- Selecting smaller bandwidths closer to the cutoff provides better (linear) fits of the underlying data

- You can also weight observations within the bandwidth.

- BUT: bias-efficiency tradeoff!

- Statistical software ( rdrobust ) will select a bandwidth to optimize this tradeoff.

]


.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rddbw.png" width="500px" /&gt;
]


---

### Cross-Validation Approaches

.fnsize[
- Pick a proportion `\(p\)` of data on either side of the cutoff to use for **validation**.

- Start with the first observation to the left of the cutoff. We can observe the **outcome** for this observation.  

- Using a given functional form, kernal weight and bandwidth, see how well we can predict this outcome (using a regression model).

- Calculate the prediction error.

- Repeat for all observations in the validation dataset (on both sides of the continuity).

- Compute the mean squared error (MSE).

- Repeat for other bandwidths.

- Choose the bandwidth which minimizes the MSE (assuming a given kernal weight and functional form), and use this to estimate `\(\hat{\tau}^{RD}\)`.

- Ideally, you will obtain the roughly the same estimate of `\(\hat{\tau}^{RD}\)` across all of your analytical choices.
]

---

### Summary

RD estimation requires a lot of choices:

- functional form

- kernal weight

- bandwidth

&lt;br&gt;

You should plot your data to illustrate the appropriateness of your choices.

But also lots of robustness checks to show roughly similar results across all analytical choices.


---

### Hainmueller et al.

.pull-left[

- What is the research question?

  - Threats to inference in observational data?
  
&lt;br&gt;  
  
- Describe the RD design:

  - What is the sample?
  
  - What is rating variable?
  
  - What is the treatment?

]

.pull-right[

Double-selection bias:

&lt;img src="https://nanzhangresearch.github.io/rdgraphics/hainmueller_selection.png" width="700px" /&gt;

]

---

### Covariate Balance


.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/hainmueller_fig31.png" width="700px" /&gt;
]

---

### Covariate Balance


.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/hainmueller_balances.png" width="400px" /&gt;
]


---

### Density Tests

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/hainmueller_fig32.png" width="700px" /&gt;
]


---

### A Fuzzy RD

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/hainmueller_fig33.png" width="700px" /&gt;
]

--

&lt;br&gt;

Estimate using 2sls:

.center[

`\(\widehat{Naturalized} = \gamma_0 + \gamma_1 (Vote \, Margin - 50) + \gamma_2 Won \, Vote + \gamma_3 Interact  + \omega\)`

`\(Integration = \beta_0 + \beta_1 (Vote \, Margin - 50) + \beta_2 \widehat{Naturalized} + beta_3 Interact +  \epsilon\)`
]

---

### Robustness to Different Bandwidths

.center[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/hainmueller_bandwidths.png" width="600px" /&gt;
]

--

- Could also show robustness to different functional forms and kernal weights

- Also, could re-estimate using non-parametrically using rdrobust()


---

### RD as a Local Experiment

.pull-left[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rddexp.png" width="500px" /&gt;
]

.pull-right[

- Take a window `\(W_o = [x_0 - w_0, x_0 + w_0]\)`

  - All units within this window whose scores are below the cutoff are comparable to units whose scores are above it.

  - Treatments assigned in `\(W_0\)` are independent of potential outcomes.

- Better approach if:

  - Running variable is discrete
  
  - There are relatively few observations near the cutoff (since we do not rely upon extrapolation)

]

---

### Selecting the Window

.pull-left[

- In most RD applications, the window where a local randomization assumption is plausible will be unknown.

- Window selection implies a precision-bias tradeoff

- One idea: choose a window such that covariate balance (and the score) holds in that window and all windows contained in it.

- You should also test the robustness of the result to alternative `\(W_0\)`s.
]

.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rdwindow2.png" width="500px" /&gt;
]

---

### Selecting the Window

.pull-left[

- In most RD applications, the window where a local randomization assumption is plausible will be unknown.

- Window selection implies a precision-bias tradeoff

- One idea: choose a window such that covariate balance (and the score) holds in that window and all windows contained in it.

- You should also test the robustness of the result to alternative `\(W_0\)`s.
]

.pull-right[
&lt;img src="https://nanzhangresearch.github.io/rdgraphics/rddwindow.png" width="500px" /&gt;
]


---

### Next Week

- Unexpected Event during Survey Design (UESD) treats **time** (fieldwork days) as the running variable, and the **unexpected event** as the cutoff.  

- Examples: 

  - Terrorist attacks
  
  - Political scandals
  
  - Natural disasters
  
- Need to adapt our analyses to the practical details of fieldwork on the survey

- Please read [Legewie 2013](https://www.journals.uchicago.edu/doi/epdf/10.1086/669605) 
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "14:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
